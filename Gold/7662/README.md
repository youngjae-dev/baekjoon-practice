# [7662] 이중 우선순위 큐

## 문제 요약
이중 우선순위 큐는 다음 3가지 연산을 지원한다:
- `I n` : 정수 `n`을 삽입  
- `D 1` : 최댓값을 삭제  
- `D -1` : 최솟값을 삭제  

모든 연산을 수행한 후 큐에 남아 있는 **최댓값과 최솟값**을 공백으로 출력하라.  
큐가 비어 있다면 `"EMPTY"`를 출력한다.

## 풀이 핵심
- **오름차순 / 내림차순 우선순위 큐** 두 개를 사용한다.
- 삽입 시 두 큐에 모두 값을 넣고, `unordered_map`을 통해 각 값의 **유효성**을 `++delete_num[num]` 방식으로 관리한다.
- 삭제 시 `--delete_num[q.top()]`으로 **논리 삭제**를 표시하고, 실제로 큐의 top이 유효하지 않다면 `pop()`을 반복하여 걸러낸다.
- 최종 출력 전에도 큐에 남은 **유효하지 않은 값들**을 정리해 일관성을 유지한다.

## 시행착오 & 개선
- 초기에 단순히 두 큐에서 삽입/삭제만 수행했더니, 한 큐에서 삭제된 값이 **다른 큐에 남아 있는 문제**로 인해 출력 결과가 틀어졌다.
- 이후, 정렬된 컨테이너(`deque`)로 구현하고 `pop_front()` / `pop_back()`으로 처리하는 방식으로 개선했지만, **시간 초과**가 발생했다.
- 결국 `unordered_map`을 활용한 **논리 삭제 방식**으로 전환했고, 큐에서 값을 실제로 꺼낼 때 **해당 값이 유효한지 검사**하여 동기화를 유지했다.

## 느낀 점
- 구현이 단순하다고 해서 항상 효율적인 것은 아니며, **데이터 구조의 시간 복잡도**를 충분히 고려해야 함을 체감했다.
- `unordered_map`으로 유효성 마킹을 하며 삭제를 지연시키는 방식은 **논리 삭제**로, **두 개의 우선순위 큐 동기화 문제를 해결**할 수 있었다.
- 여러 시행착오 끝에 완성도 있는 풀이로 문제를 해결하면서, 스스로 한 단계 성장했음을 느낄 수 있는 의미 있는 경험이었다.