# [9251] LCS

## 문제 요약
두 수열이 주어졌을 때, LCS(Longest Common Subsequence, 최장 공통 부분 수열)을 찾아 그 길이를 출력하라.

## 풀이 핵심
- 다이나믹 프로그래밍을 사용해 수열 A와 B의 LCS 길이를 저장한다.
- dp[i][j]는 A의 앞 i글자와 B의 앞 j글자가 만들어낼 수 있는 LCS 길이를 저장한다.
- 점화식
  ```cpp
  // 문자가 같을 경우 : 수열 길이 + 1
  if (A[i - 1] == B[j - 1]) {
	  dp[i][j] = dp[i - 1][j - 1] + 1;
  }
  // 문자가 다를 경우 : 이전까지의 LCS 중 더 긴 쪽 선택
  else {
	  dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
  }
  ```

## 시행착오 & 개선
- 처음에는 A와 B 각각을 기준으로 두 번 탐색해야 한다고 착각했다.
- 하지만, dp배열을 사용해 한 번의 이중 반복문으로 간단히 풀이할 수 있었다.

## 느낀 점
- 다이나믹 프로그래밍 관련 문제들을 점점 많이 접해보니까 이제 전보다는 확실히 점화식을 세우는데 익숙해진 것 같다.
- 다이나믹 프로그래밍은 물론 몇차원 배열을 사용할건지와 무엇을 기준으로 다이나믹 프로그래밍을 할지 등 고려해야할 부분이 많지만, 결국 핵심은 올바른 점화식을 세우는 데 있다.