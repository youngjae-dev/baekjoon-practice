# [9019] DSLR

## 문제 요약
`D`, `S`, `L`, `R` 네 개의 명령어가 가능한 계산기가 있다. 각 명령어는 다음과 같은 연산을 한다.

- `D` : n -> (2n mod 10000)
- `S` : n -> n-1 (단, 0일 경우 9999 저장)
- `L` : 각 자릿수를 왼편으로 회전(1234 -> 2341)
- `R` : 각 자릿수를 오른편으로 회전(1234 -> 4123)

두 정수 A, B가 주어졌을때, A를 B로 변환하기 위한 최소한의 명령어 나열을 출력하라.(가능한 경우가 여러 개일 경우 아무거나 출력해도 된다)

## 풀이 핵심
- BFS 수행시 사용하는 큐를 `pair<int, string>` 형식으로 구성해 현재 숫자와 그에 도달하기까지의 **명령어 나열**을 함께 저장한다.
- 회전 연산(`L`, `R`)은 아래와 같은 수식으로 처리한다.
  - 왼쪽 회전(`L`): `num = (curr % 1000) * 10 + curr / 1000`
  - 오른쪽 회전(`R`): `num = (curr / 10) + (curr % 10) * 1000`
- 명령어 문자열 누적은 `tmp + cmd[i]` 방식으로 수행한다.(`tmp.push_back(cmd[i])`은 원본 문자열이 바뀌어 **후속 명령어에 영향**을 준다.)

## 시행착오 & 개선
- 처음엔 `L`, `R` 명령어 구현을 위해 숫자를 문자열로 변환(`stoi`/`to_string`)해서 처리했으나, **간단한 수식만으로 처리 가능**하다는 것을 깨닫고 코드 구조를 단순화했다.
- 명령어 누적을 `tmp.push_back(cmd[i])`로 구현했을 땐, 원본 문자열이 바뀌어 후속 명령어에 영향을 줬다.
- 이를 `tmp + cmd[i]`로 바꾸어 안전하게 누적하도록 수정하였다.
- `curr` 값을 직접 수정하다가 연쇄적인 값 오류가 발생하였다
- 이를 `num` 변수에 별도로 저장하도록 수정하였다.

## 느낀 점
- 처음엔 간단해 보였지만, 구현에 숨겨진 디테일이 많아 꽤 흥미롭게 풀 수 있었던 문제였다.
- 변수를 수정하는 방식이 이후 연산에 미치는 영향을 고려하면서, 값을 복사하거나 별도의 변수에 저장하는 습관을 들여야겠다고 느꼈다.
- BFS 기반 그래프 탐색 문제가 골드 티어에서 매우 자주 등장한다는 점을 보며, 앞으로도 다양한 변형 문제를 많이 접해야겠다는 동기부여가 되었다.