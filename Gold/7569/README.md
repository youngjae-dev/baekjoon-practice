# [7569] 토마토

## 문제 요약
격자 모양의 상자에 토마토를 넣고, 상자들을 위로 H개 쌓아 창고에 보관한다.  
익은 토마토는 하루가 지나면 인접한 방향(위, 아래, 왼쪽, 오른쪽, 앞, 뒤)의 안 익은 토마토를 익게 만든다.

다 익는 데 걸리는 **최소 일수**를 구하라.  
단, **모든 토마토가 익지 못하는 경우 -1을 출력**한다.

- M: 가로 칸 수
- N: 세로 칸 수
- H: 상자의 높이(층 수)

## 풀이 핵심
- 익은 토마토들이 들어오는 족족, `queue`에 삽입한 뒤에 모든 익은 토마토들에 대해 `BFS`를 수행한다.

- 탐색 시에 6방향(위, 아래, 왼쪽, 오른쪽, 앞, 뒤)에 대해 수행해야하므로 각각의 방향에 대해 배열을 관리한다.

- `익은 날짜 = 이전 날짜 + 1`을 활용해, 각 토마토가 익는 시점을 박스에 그대로 누적하며 갱신했다.

## 시행착오 & 개선
- 처음에는 방문 여부를 확인하는 `visited`와 익은 토마토의 위치를 저장하는 `tomato` 벡터를 사용해 BFS를 수행하려고 했다.

- 하지만 `visited`는 해당 위치의 토마토가 0인지 여부만 확인하면 방문 여부 또한 알 수 있기 때문에 필요 없다고 판단해 제거했다.

- 또, `tomato` 벡터는 익은 토마토의 위치를 모두 순회하면서 처리하기보다는, 애초에 큐에 한 번에 삽입해 모든 점에 대해 BFS를 수행하는 게 훨씬 더 간편하다고 판단해 제거했다.

- 토마토가 모두 익은 날짜를 출력하기 위해 따로 관리하려 했으나, `익은 날짜 = 이전 날짜 + 1` 방식으로 각 칸에 누적 갱신하면 된다는 점을 깨닫고 수정했다.

## 느낀 점
- 다른 문제들을 풀면서 항상 느끼는 거지만 특히 이번 문제에서 `visited`, `tomato` 같이 불필요한 변수 선언과 `익은 날짜 = 이전 날짜 + 1` 같은 효율적인 값 갱신처럼 유독 코드의 간소화를 시킬 수 있는 부분이 많았던 것 같다.

- 앞으로도 이런 구조적 단순화에 민감해지면서, 짧고 명확한 코드로 문제를 해결해 나가고 싶다.