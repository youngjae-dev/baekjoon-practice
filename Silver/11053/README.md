# [11053] 가장 긴 증가하는 부분 수열

## 문제 요약  
주어진 수열 A에서 가장 긴 **증가하는 부분 수열**의 길이를 구하라.

예)
A = {10, 20, 10, 30, 20, 50} -> 가장 긴 증가하는 부분 수열은 `{10, 20, 30, 50}`로 길이는 4이다.

## 풀이 핵심  
- 다이나믹 프로그래밍(DP)을 이용해 각 인덱스를 기준으로 **최장 증가 부분 수열의 길이**를 갱신한다.
- `dp[i]`는 `i`번째 원소를 마지막으로 하는 가장 긴 증가하는 부분 수열의 길이를 의미한다.
- 이중 반복문을 통해 `i` 이전의 인덱스들을 모두 확인하고, `numbers[j] < numbers[i]`인 경우 `dp[i] = max(dp[i], dp[j] + 1)`로 갱신한다.
- 모든 `dp[i]`를 갱신한 후, 그 중 **최댓값이 정답**이 된다.

## 시행착오 & 개선  
- 처음에는 수열을 순회하면서 이전 값보다 크면 카운트를 증가시키는 방식으로 접근했으나, 이 방법은 **항상 0번째부터 시작**해야 하기 때문에 정답을 놓칠 수 있었다.
- 따라서, 모든 위치에서 증가하는 부분 수열을 시작할 수 있도록 **각 위치에서의 최장 길이를 저장하는 `dp` 배열**을 새로 만들었다.
- `dp`를 사용하면서 각 위치마다 **이전 위치들과 비교**하여 가장 최적인 상태로 갱신되도록 구현하였다.
- 또한, 전체 수열 중 최댓값을 별도 변수 `max_length`로 관리해 정답을 얻었다.

## 느낀 점  
- 예전 백트래킹 문제처럼 한 변수를 여러 목적에 사용해보려 했지만, 이 문제는 **명확히 역할을 분리한 변수**가 더 효율적이었다.
- **코드를 간결하게 만드는 것보다 정확한 역할을 수행하는 변수를 쓰는 것**이 중요하다는 걸 깨달았다.
- DP 문제는 겉으로 보기에 쉬워 보여도 **문제 구조를 파악하고 점화식을 세우는 게 어렵다**는 걸 다시 한번 느꼈다.
- 다양한 문제를 접하면서 **알고리즘적 사고**가 확장되고 있고, 이런 경험이 **개발자로서 문제 해결 능력**을 키우는 데 큰 도움이 된다는 걸 느꼈다.