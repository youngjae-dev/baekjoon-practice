# [17626] Four Squares 문제 풀이

## 문제 요약  
정수 N이 주어졌을 때, 제곱수들의 합으로 표현하는 최소 개수를 구하는 문제

## 풀이 핵심  
- 점화식: dp[i] = min(dp[i], dp[i - j*j] + 1)  
- dp[i]는 i를 제곱수들의 합으로 만들 수 있는 최소 개수  
- 가능한 모든 j*j (j*j ≤ i)를 탐색하면서 최솟값 갱신  
- 초기값: dp[i] = i (전부 1^2로 구성한다고 가정한 최악의 경우)

## 시행착오 & 개선  
- 처음엔 가장 큰 제곱수 하나만 쓰고 나머지를 dp로 처리해서 풀었음
```cpp
int tmp = sqrt(i);
tmp = pow(tmp, 2);
dp[i] = dp[tmp] + dp[i - tmp];
```
- 그런데 이렇게 하면 항상 최소 개수를 보장하지 않아서 오답  
- 모든 제곱수를 순회하며 최소값을 비교하는 점화식으로 바꾼 뒤 해결됨

## 느낀 점
- 처음에는 “제일 큰 제곱수 하나만 쓰면 최소가 되겠지”라는 직관에 의존했지만, 그게 항상 최적의 해를 보장하지 않는다는 걸 알게 되었다.
- 따라서 점화식을 구성할 때, 해당 숫자의 최악의 경우(모두 1²로 구성)와 그 숫자에서 제곱수를 하나씩 빼 본 여러 경우의 수를 비교하여, 최솟값으로 갱신하는 방식으로 수정했다.
- 특히 `dp[i] = min(dp[i], dp[i - j*j] + 1)` 같은 점화식은 작성은 간단하지만, 아이디어를 떠올리는 데 시간이 걸리는 유형이라는 걸 느꼈다.