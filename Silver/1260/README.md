# [1260] DFS와 BFS 문제 풀이

## 문제 요약
정점의 개수 N, 간선의 개수 M, 탐색 시작 정점 V가 주어진다.
정점은 1번부터 N번까지 존재한다.
DFS와 BFS를 각각 수행한 결과를 출력한다.
(단, 여러 정점이 연결된 경우에는 정점 번호가 낮은 것부터 방문해야 한다.)

## 풀이 핵심
- 무방향 그래프를 직접 클래스 및 구조체(Vertex, Edge, Graph)로 구현
- 간선 삽입 시, 양쪽 정점의 `incident_edges`에 정점 번호 기준 오름차순으로 정렬되도록 삽입
- DFS는 재귀 방식, BFS는 큐 기반으로 구현
- 방문 여부는 `UNEXPLORED` / `VISITED` 상태로 관리
- 탐색이 끝난 뒤엔 `reset()` 함수를 통해 상태를 초기화

## 시행착오 & 개선
- 처음엔 간선을 삽입할 때 `new_edge`의 반대 정점(opposite)과 기존 간선들의 opposite을 비교해야 했지만
  `iterator`를 2개나 쓰는 바람에 의도한 대로 정렬 삽입이 되지 않았음
- 이로 인해 DFS/BFS 탐색 순서가 정점 번호 오름차순이 되지 않는 문제가 발생
- `incident_edges`에 간선을 삽입할 때 `opposite(e, v)->vid` 기준으로 정렬되도록 수정
- 삽입 정렬 방식으로 구현하여 정점 번호가 낮은 순서대로 탐색되도록 보장함

## 느낀 점
- 정점 번호의 오름차순 탐색을 위해 `InsertEdge()` 함수 내에서 간선을 인접 리스트에 정렬 삽입되도록 설계했다
- 직접 `Graph`, `Vertex`, `Edge` 클래스를 만들면서 그래프 구조와 탐색의 흐름을 구조적으로 이해할 수 있었음
