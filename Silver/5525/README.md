# [5525] IOIOI

## 문제 요약
N과 M이 주어질 때, 문자열 `Pn`이 문자열 `S`에 몇번 속해있는지 구하여라

- `N` : Pn의 IOI 패턴이 반복되는 횟수
- `Pn` : `"IOIOI..."`의 형태로, `N+1`개의 `I`와 `N`개의 `O`로 이루어진 문자열
- `M` : 문자열 `S`의 길이

## 풀이 핵심
- `Pn`은 `IOI`패턴이 N번 반복된 구조이므로, S에서 `IOI`가 N번 등장하는 회수를 세면된다.
- `IOI` 패턴이 등장할때마다 `pattern`변수를 증가시킨다.
- `pattern == N`이 되면 `count++`하고, 패턴의 겹치는 부분을 고려해 `pattern--` 해준다.
- 예) `IOIOIOI`가 있다고할때, `IOIOI`가 처음 발견되고 `pattern`을 -1 해주지 않으면 두번째 `IOIOI`발견시에 `pattern`의 값이 3이 되서 올바르게 카운트 되지 않는다.
- 패턴이 깨지는 순간 `pattern`을 다시 0으로 초기화
- 반복문을 돌 때, `i=1`부터 `M-2`까지 돌면서 `str[i-1], str[i], str[i+1]`을 `IOI`와 비교한다.
- 패턴 비교 시에 시작점이 `I`가 되어야 하므로 `IOI`패턴 등장시에 인덱스 `i++`을 해준다.

## 시행착오 & 개선
- 처음에는 `N`을 기반으로 직접 `Pn` 문자열을 만들어 `char*`로 저장하고, 슬라이싱하여 비교했지만, `N<=100, M<=10,000`이라는 제한조건에서만 성립해서 50점 밖에 맞지 못하였다.
- 이후 `Pn`의 구조가 단순히 `IOI`가 `N`번 반복된 것이라는 점을 깨닫고, 단순 반복문과 조건문만으로 효율적으로 해결했다.
- 특히 `pattern`과 `i++`, 그리고 `pattern--` 처리를 통해 겹치는 패턴을 정확하게 처리하는게 가장 키포인트였다.

## 느낀 점
- 문자열 비교보다는 패턴의 구조를 이해하는 것이 핵심이라는 걸 다시금 느꼈다.
- 과거에는 무조건 문자열 슬라이싱 후 비교를 우선적으로 생각했는데, 이번 문제를 통해 문자열 내부의 규칙을 분석하면 더 간단하고 효율적으로 풀 수 있다는 걸 경험했다.
- 앞으로도 문자열 문제를 만났을 때 조건문과 반복문으로 패턴을 직접 추적하는 방법을 먼저 고려해볼 필요가 있겠다.